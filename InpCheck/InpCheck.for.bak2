!=======================================================================
!=================== Start of Program InpCheck =========================
c --- AUTHOR:  MPelton and, JRishel
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Program InpCheck

c --- Data declarations
      DATA ver/'25-Apr-07'/

c --- Function type declarations 
c --- trust me you need them
c --- you get very unpredicatble behavior
c --- unless the name starts with correct
c --- default type letter
      Logical CalcNumObs
      Logical CheckEnds
      Logical CheckLeap
      Real CalcWindDir

c --- File and temp variable declarations 
      Integer ieUnt
      Integer icUnt
      Integer isIUnt
      Integer isOUnt
      Integer i, j, k, n, nObs, nLev, bIdx, eIdx
      Integer kYr, kJd, kHr, yrLen
      Character ver
      Character*80 des

c --- Declarations for upper air checks and fill
	real, ALLOCATABLE:: zsub(:),psub(:),tsub(:)
	real, ALLOCATABLE:: dsub(:),ssub(:),sigma(:)
	real m,b
	real pmiss,zmiss,tmiss,dmiss,smiss
	integer nlevels,ncomplete,nglevels

c --- Bwiccalmet.inp info
      Character*250 path
      Character*80 run
      Real xSw
      Real ySw
      Integer uZone
      Real xySz
      Integer xNum
      Integer yNum
      Integer sYr, sMn, sDy, sJd, sHr
      Integer yr, jd, hr
      Integer TZ
      Integer sLen
      Character topo
      Character*80, ALLOCATABLE::datName(:) 

c --- Upper surface station info
      Integer sNum
      Character*80, ALLOCATABLE::sname(:) 
      Character*20, ALLOCATABLE::slat(:), slng(:) 
      Integer, ALLOCATABLE::sId(:), sTZ(:), anem(:) 

c --- Upper air station info
      Integer aNum
      Character*80, ALLOCATABLE::aname(:) 
      Character*20, ALLOCATABLE::alat(:), alng(:) 
      Integer, ALLOCATABLE::aId(:), aTZ(:), aht(:) 

c --- station .dat info
      Real pstop
      Logical Done, anErr
      Logical lht, ltemp, lwd, lws
      Integer ibYr, ibJd, ibHr, ieYr, ieJd, ieHr
      Integer jdat, ifmt, iTZ, nSta
      Real, ALLOCATABLE::tempk(:,:), pres(:,:), ht(:,:)
      Real, ALLOCATABLE::u(:,:), v(:,:), ws(:,:), wd(:,:)
      Integer, ALLOCATABLE::iws(:,:), iwd(:,:)
      Integer, ALLOCATABLE::iId(:), iceil(:, :), icc(:,:), irh(:,:) 
      Integer, ALLOCATABLE::iYr(:), iJd(:), iHr(:), ipcode(:,:)
      Integer, ALLOCATABLE::itpdk(:), iMn(:), iDy(:), mLev(:), iStop(:)
      Character*6, ALLOCATABLE::isId(:)
      
c --- File unit assignments
      ieUnt = 1
      icUnt = 2
      isIUnt = 3
      isOUnt = 4      

c --- Open error log      
      Open(UNIT=ieUnt, FILE='inpCheck.log', STATUS='replace') 

c --- Open and Read bwiccalmet.inp      
      Open (UNIT=icUnt, FILE='BWICCALMET.INP', STATUS='OLD') 
      Read(icUnt,*) path, des
      Read(icUnt,*) run, des
      Read(icUnt,*) xSw, des
      Read(icUnt,*) ySw, des
      Read(icUnt,*) uZone, des
      Read(icUnt,*) xySz, des
      Read(icUnt,*) xNum, des
      Read(icUnt,*) yNum, des
      Read(icUnt,*) sYr, des
      Read(icUnt,*) sMn, des
      Read(icUnt,*) sDy, des
      Read(icUnt,*) sHr, des
      Read(icUnt,*) TZ, des
      Read(icUnt,*) sLen, des
      Read(icUnt,*) topo, des

c --- Read Surface station data
      Read(icUnt,*) sNum, des      
      Read(icUnt,70) des, des, des, des, des, des
      ALLOCATE(sname(sNum), slat(sNum), slng(sNum)) 
      ALLOCATE(sId(sNum), sTZ(sNum), anem(sNum)) 
      Do i = 1, sNum
        Read(icUnt,*) sname(i),sId(i),slat(i),slng(i),sTZ(i),anem(i) 
      End Do

c --- Read upper air station data      
      Read(icUnt,*) aNum, des
      Read(icUnt,70) des, des, des, des, des, des
      ALLOCATE(aname(aNum), alat(aNum), alng(aNum)) 
      ALLOCATE(aId(aNum), aTZ(aNum), aht(aNum)) 
      Do i = 1, aNum
        Read(icUnt,*) aname(i),aId(i),alat(i),alng(i),aTZ(i),aht(i)
      End Do

c --- Read file names     
      ALLOCATE(datName(aNum+1)) 
      Read(icUnt,*) datName(1) 
      Read(icUnt,70) des, des
      Do i = 2, aNum+1
        Read(icUnt,*) datName(i) 
      End Do
      Close(icUnt, STATUS='KEEP') 

c --- Calculate Ending time from .inp file
      call julday(ieUnt, sYr, sMn, sDy, sJd) 
      hr = MOD(sLen+sHr, 24) 
      jd = sJd + (sLen+sHr) /24
      If (CheckLeap(yr).EQ..TRUE.) Then
        yr = sYr + jd/366
        jd = MOD(jd, 366) 
      Else
        yr = sYr + jd/365
        jd = MOD(jd, 365) 
      End If
cLst
      Write(ieUnt,*) 'Simulation start time', sYr, sJd, sHr
      Write(ieUnt,*) 'Simulation End time', yr, jd, hr
      Write(ieUnt,*) 'The simulation length ', sLen
      Write(ieUnt,*) 'Done Reading BWICCALMET.inp'
      Write(*,*) 'Done Reading BWICCALMET.inp'
c      Read(*,*) topo
cLst
c=======================================================================
c --- Open and Read an unformatted surf.dat file     
c=======================================================================
      anErr = .FALSE.
      Open(UNIT=isIUnt, FILE=datName(1), STATUS='OLD')
      Read(isIUnt,*) ibYr, ibJd, ibHr, ieYr, ieJd, ieHr, TZ, nSta
      anErr = CalcNumObs(ieUnt, ibYr, ibJd, ibHr,
     1                   ieYr, ieJd, ieHr, nObs)
      If (anErr) then
        write(ieIUnt,*) 'CalcNumObs failed!'
        Goto  1000
      End If

c --- Allocate space for processing
      i = nObs
	j = nSta
      ALLOCATE(iId(j), iYr(i), iJd(i), iHr(i)) 
      ALLOCATE(u(i,j), v(i,j)) 
      ALLOCATE(ws(i,j), wd(i,j), tempk(i,j), pres(i,j)) 
      ALLOCATE(iceil(i,j), icc(i,j), irh(i,j), ipcode(i,j))

      Read(isIUnt,*) (iId(i), i=1, nSta) 
      Do i=1, nObs
        Read(isIUnt,*) iYr(i), iJd(i), iHr(i) 
        Do j=1, nSta
          Read(isIUnt,*) ws(i,j), wd(i,j), iceil(i,j), icc(i,j), 
     1             tempk(i,j), irh(i,j), pres(i,j), ipcode(i,j)    
        End Do
      End Do
cLst
      Write(ieUnt,*) 'Surface data start time', ibYr, ibJd, ibHr
      Write(ieUnt,*) 'Surface data End time', ibYr, ieJd, ieHr
      Write(ieUnt,*) 'Finished reading ', datName(1) 
      Write(*,*) 'Finished reading ', datName(1) 
c        Read(*,*) topo
cLst

c --- Process the surf.dat file for errors
c       a.      Ceiling Height: 100 (thousands of feet) 
c       b.      Cloud Cover: 0 (tenths) 
c       c.      Temperature: 298.0 (K) 
c       d.      Relative Humidity: 50 (%) 
c       e.      Pressure: 1013.25 (mb) 
c       f.      Wind Speed: 0 (m/s) ; Direction 0 (degrees) 

      anErr = CheckEnds(ieUnt, sYr, sLen, nObs, sJd, sHr,
     1        yr, jd, hr, iYr, iJd, iHr, bIdx, eIdx)
      If (anErr) Then
	  write(ieUnt,*) 'CheckEnds failed!'
        goto 1000
      End If

      call ifillvalues(nSta, nObs, bIdx, eIdx, iceil, 100) 
      call ifillvalues(nSta, nObs, bIdx, eIdx, icc, 0) 
      call ifillvalues(nSta, nObs, bIdx, eIdx, irh, 50) 
c      call ifillvalues(nSta, nObs, bIdx, eIdx, ipcode, 0) 
      call rfillvalues(nSta, nObs, bIdx, eIdx, tempk, 298.0) 
      call rfillvalues(nSta, nObs, bIdx, eIdx, pres, 1013.25) 
    
c --- can not just average values for speed and direction
c --- we must first convert to u and v components
      Do j=1, nSta
        Do i=bIdx-1, eIdx+1
          If (wd(i,j).NE.9999.0) Then
            wdrad = 0.0174533 * wd(i,j) 
            u(i,j) = -ws(i,j) * sin(wdrad) 
            v(i,j) = -ws(i,j) * cos(wdrad) 
          Else
            u(i,j) = 9999.0
            v(i,j) = 9999.0
          End If
        End Do
      End Do
     
c --- Fill and average u and v components
      call rfillvalues(nSta, nObs, bIdx, eIdx, u, 0) 
      call rfillvalues(nSta, nObs, bIdx, eIdx, v, 0) 

c --- Convert from u and v components
      Do j=1, nSta
        Do i=bIdx-1, eIdx+1
          If (u(i,j).NE.9999.0) Then
            ws(i,j) = sqrt(u(i,j)*u(i,j) + v(i,j)*v(i,j)) 
            If (ws(i,j).NE.0.0) Then
              wd(i,j) = CalcWindDir(u(i,j), v(i,j), ws(i,j)) 
            Else
              wd(i,j) = 0
            End If 
          End If
        End Do
      End Do

1000  Close(isIUnt,STATUS='KEEP') 
cLst
      Write(ieUnt,*) 'Finished surface observation checks'
      Write(*,*) 'Finished surface observation checks'
c        Read(*,*) topo
cLst

c=======================================================================
c --- Open and Write formatted surf.dat file     
c=======================================================================
      If (.NOT. anErr) Then
	  write(*,*) 'crapola', anErr
        Open(UNIT=isOUnt, FILE=datName, STATUS='replace') 
        Write(isOUnt,100) ibYr, ibJd, ibHr, ieYr, ieJd, ieHr, TZ, nSta
        Write(isOUnt,110) (iId(i), i=1, nSta) 
        Do i=1, nObs
          Write(isOUnt,120) iYr(i), iJd(i), iHr(i) 
          Do j=1, nSta
            Write(isOUnt,130) ws(i,j), wd(i,j), iceil(i,j), icc(i,j), 
     1                  tempk(i,j), irh(i,j), pres(i,j), ipcode(i,j)     
          End Do
        End Do
        Close(isOUnt) 
cLst
        Write(ieUnt,*) 'Finished writing ', datName(1) 
        Write(*,*) 'Finished writing ', datName(1) 
c        Read(*,*) topo
cLst
      End If

c --- Deallocate space for processing
      DEALLOCATE(iceil, icc, irh, ipcode, STAT=k) 
      DEALLOCATE(iId, iYr, iJd, iHr, STAT=k) 
      DEALLOCATE(tempk, pres, STAT=k) 
      DEALLOCATE(ws, wd, STAT=k) 
      DEALLOCATE(u, v, STAT=k) 

c=======================================================================
c --- Open and Read formatted up(n).dat file     
c=======================================================================
	Do n=2, aNum+1
        anErr = .FALSE.
        Write(*,*) 'Reading ', datName(n)
        Open(UNIT=isIUnt, FILE=datName(n), STATUS='OLD')     
        Read(isIUnt,140) ibYr, ibJd, ibHr, ieYr,
     1                   ieJd, ieHr, pstop, jdat, ifmt
        Read(isIUnt,150) lht, ltemp, lwd, lws
        anErr = CalcNumObs(ieUnt,ibYr,ibJd,ibHr,
     1                     ieYr,ieJd,ieHr,nObs)
        if (anErr) then
          write(ieIUnt,*) 'CalcNumObs failed!'
          Goto 2000
        end if

c ---   Allocate space for processing for up to fifty levels 
	  nLev = 50
        nObs = nObs/12 + 1
        i = nObs+1
        j = nLev
        ALLOCATE(itpdk(i), isId(i), iYr(i), iJd(i), iHr(i)) 
        ALLOCATE(iMn(i), iDy(i), mLev(i), iStop(i)) 
        ALLOCATE(u(i,j), v(i,j), iws(i,j), iwd(i,j)) 
        ALLOCATE(tempk(i,j), pres(i,j), ht(i,j)) 

        i = 1
        k = 0
        kHr = ibHr
        kJd = ibJd
        kYr = ibYr
        If (CheckLeap(ibYr).EQ..TRUE.) Then 
          yrLen = 365
        Else
          yrLen = 364
        End If
        Do While (k.EQ.0 .AND. i.LE.nObs)
          Read(isIUnt,160,IOSTAT=k) itpdk(i), isId(i), iYr(i), iMn(i), 
     1                     iDy(i), iHr(i), mLev(i), iStop(i)
          If (k.EQ.0) Then 	    
            call julday(ieUnt, iYr(i), iMn(i), iDy(i), iJd(i))
		  If (iHr(i).EQ.kHr .AND. iJd(i).EQ.kJd .AND. 
     1          iYr(i).EQ.kYr) Then
              khr = mod(kHr+12, 24) 
              If (kHr.EQ.0) Then
                kJd = kJd+1
              End If
              If (kJd/yrlen.EQ.1) Then
                kJd = 0
                kYr = kYr+1
                If (CheckLeap(kYr)) Then 
                  yrLen = 365
                Else
                  yrLen = 364
                End If 
              End If
              tIdx = i
              i = i+1
              iStop(i) = iStop(i-1)
            Else
              tIdx = nObs + 1
            End If
            Read(isIUnt,170,IOSTAT=k)
     1        (pres(tIdx,j), ht(tIdx,j), tempk(tIdx,j),
     2         iwd(tIdx,j), iws(tIdx,j), j=1, iStop(i))
          End If
        End Do
cLst
        Write(ieUnt,*) 'Upper air data start time', ibYr, ibJd, ibHr
        Write(ieUnt,*) 'Upper air data end time', ibYr, ieJd, ieHr
        Write(ieUnt,*) 'Finished reading ', datName(n)
        Write(*,*) 'Finished reading ', datName(n) 
c        Read(*,*) topo
cLst
        
	  If (i.NE.nObs+1) Then
          anErr = .TRUE.
	    write(ieUnt,*)
     1       'Number of observations read do not match expected'
          Goto 2000
        End If

        anErr = CheckEnds(ieUnt, sYr, sLen, nObs, sJd, sHr,
     1      yr, jd, hr, iYr, iJd, iHr, bIdx, eIdx)
        If (anErr.EQ..TRUE.) Then
	    Write(ieUnt,*) 'CheckEnds failed!'
          Goto 2000
        End if


c=======================================================================
c=======================================================================

c       CALMET missing value indicators
        pmiss = -99.0
        zmiss = 9999.0
        tmiss = 999.9
        dmiss = 999
        smiss = 999


c       determine if sufficient number of levels in sounding to
c       perform filling (note: two COMPLETE levels are required).
        do i=1,nObs
          ALLOCATE(zsub(nLev),psub(nLev),tsub(nLev))
          ALLOCATE(dsub(nLev),ssub(nLev),sigma(nLev))
          do j=1,iStop(i)
            if ((ht(i,j).NE.zmiss) .AND. (pres(i,j).NE.pmiss) .AND.
     &          (tempk(i,j).NE.tmiss) .AND. (iwd(i,j).NE.dmiss) .AND.
     &          (iws(i,j).NE.smiss)) then
          ncomplete = ncomplete + 1
            end if
c           build subset array of good height/pressure values 
c           for linear regression only include points where both 
c           (height) and (pressure) exist
          if ((ht(i,j).NE.zmiss).AND.(pres(i,j).NE.pmiss)) then
c         increment count for number of good levels
          nglevels = nglevels + 1
c         create sub array that contains all non-missing height.AND.pressure levels
c         these sub arrays are the arrays that will be filled
          zsub(nglevels) = ht(i,j)
c         (note: pressure must be log to be of form y=mx+b)
          psub(nglevels) = log10(pres(i,j))
          tsub(nglevels) = tempk(i,j)
          dsub(nglevels) = iwd(i,j)
          ssub(nglevels) = iws(i,j)
c         uncertainty sigma(i) associated with psub(i); note: assume normal)
          sigma(nglevels) = 1.0
          endif
          end do
      
          if (ncomplete.lt.2) then
            write(ieUnt,*) 'ncomplete = ', ncomplete, 
     &      ' levels - not enough data to build sounding    '
            anErr = .TRUE.
            Goto 2000
c         (replace: add code - not enough complete levels
c            - need to persist previous sounding
c          OR build sounding if no soundings are good.)
          else
c           fill sounding, level-by level
c           if height or pressure is missing,
c           use linear regression equation to calculate values
c           if temperature, wind speed, or wind direction is missing,
c           interpolate between complete levels   
            write(ieUnt,*) 'ncomplete = ', ncomplete, '  levels'
            write(ieUnt,*) 'nglevels = ', nglevels, 
     &       ' number of levels with both pressure and height'

c           test values for routines
            call lineregress(m,b,sigma,zsub,psub,nglevels)

            do j=1,iStop(i)
c             using linear relationship for height and pressure
c             from subroutine lineregress, calculate the unknown 
c             pressure p or height z depending on which value exists
              if (ht(i,j).EQ.zmiss) then
                ht(i,j) = (log10(p)-b)/m
                write(ieUnt,*) 'z = ', ht(i,j), '  meters'
              end if
              if (pres(i,j).EQ.pmiss) then
                pres(i,j)=10**(m*z+b)
                write(ieUnt,*) 'p = ', pres(i,j), '  mb'
              end if
            end do
          end if
          DEALLOCATE(zsub,psub,tsub)
          DEALLOCATE(dsub,ssub,sigma)
        end do

c=======================================================================
c=======================================================================


2000    Close(isIUnt,STATUS='KEEP')

cLst
        Write(ieUnt,*) 'Finished upper air observation checks'
        Write(*,*) 'Finished upper air observation checks'
c	  Read(*,*) topo
cLst

        

c=======================================================================
c ---   Open and Write formatted up(n) .dat file     
c=======================================================================
        If (.NOT. anErr) Then
          Open(UNIT=isOUnt, FILE=datName(n), STATUS='replace') 
c ---     Set start time
          ibYr=sYr
          ibJd=sJd
          ibHr=sHr
          call NextTime(ibYr,ibJd,ibHr,-48)
c ---     Set end time
          ebYr=sYr
          ebJd=sJd
          ebHr=sHr
          call NextTime(ebYr,ebJd,ebHr,sLen+48)

          Write(isOUnt,140) ibYr, ibJd, ibHr, ibYr, ieJd, ieHr,
     1                    pstop, jdat, ifmt
          Write(isOUnt,150) lht, ltemp, lwd, lws


          Do i=1, nObs

            call julday(ieUnt, iYr(i), iMn(i), iDy(i), iJd(i))
		  If (iHr(i).EQ.kHr .AND. iJd(i).EQ.kJd .AND. 
     1          iYr(i).EQ.kYr) Then

            Write(isOUnt,160) itpdk(i), isId(i), iYr(i), iMn(i),
     1                      iDy(i), iHr(i), mLev(i), iStop(i) 
            Write(isOUnt,170) (pres(i,j), ht(i,j), tempk(i,j),
     1                         iwd(i,j), iws(i,j), j=1, iStop(i))
          End Do
          Close(isOUnt)
cLst
          Write(ieUnt,*) 'Finished writing ', datName(n) 
          Write(*,*) 'Finished writing ', datName(n) 
c          Read(*,*) topo
cLst   
        End If

c ---   Deallocate space for processing for up to fifty levels 
        DEALLOCATE(itpdk, isId, iYr, iJd, iHr, STAT=k) 
        DEALLOCATE(iMn, iDy, mLev, iStop, STAT=k)
        DEALLOCATE(u, v, iws, iwd, STAT=k)
        DEALLOCATE(tempk, pres, ht, STAT=k)
      End Do
      
c --- Deallocate space for input processing
      DEALLOCATE(sname, slat, slng) 
      DEALLOCATE(sId, sTZ, anem) 
      DEALLOCATE(aname, alat, alng) 
      DEALLOCATE(aId, aTZ) 
      Write(*,*) 'Fin'
      
c --- inp line formats
 70   format(a,a,a,a,a,a,a) 
 80   format(a,i,a,a,i,i) 
c --- Surf.dat line formats
 90   format(i2.2,i4.2,i4.2,i4.2,i4.2,i4.2,i4.2,i4.2,i4.2) 
100   format(i6,i4,i4,i6,i4,i4,i5,i5) 
110   format(i8,i8,i8,i8,i8) 
120   format(i2.2,i4,i4) 
130   format(f9.3,f9.3,i5,i5,f9.3,i5,f9.3,i5) 
c --- up.dat line formats
140   format(1x,6i5,f5.0,2i5) 
150   format(5x,l1,4x,l1,4x,l1,4x,l1) 
160   format(3x,i4,5x,a5,5x,4i2,5x,i2,31x,i2) 
170   format(4(3x,f6.1,'/',f5.0,'/',f5.1,'/',i3,'/',i3))

      End
!=======================================================================
!=================== End of Program InpCheck ===========================
!=======================================================================

!=======================================================================
      Subroutine NextTime(kyr,kjd,khr,hr)
c
c --- PURPOSE: to increment or decrement the passed in date with hr
c               
c --- INPUTS:
      Integer kyr,kjd,khr,hr
c --- OUTPUT:
c
!=======================================================================

      Integer yrLen

        If (CheckLeap(kYr)) Then 
          yrLen = 365
        Else
          yrLen = 364
        End If 
	  khr = mod(kHr+hr, 24) 
        If (kHr.EQ.0) Then
          kJd = kJd+1
        End If
        If (kJd/yrlen.EQ.1) Then
          kJd = 0
          kYr = kYr+1
        End If
      End


!=======================================================================
      Logical Function CalcNumObs(ieUnt, ibYr, ibJd, ibHr,
     1                            ieYr, ieJd, ieHr, nObs)
c
c --- PURPOSE:
c
c --- INPUTS:
      Integer ieUnt,ibYr,ibJd,ibHr,ieYr,ieJd,ieHr,nObs
c --- OUTPUT:
c
!=======================================================================
      
      Integer i
      Logical anErr      

c ---   check to see start date occurs before end date
      anErr = .FALSE.
      If (ibYr.GT.ieYr .OR. ibJd.GT.365 .OR. ieJd.GT.365 .OR. 
     1    ibHr.GT.23 .OR. ieHr.GT.23) Then
        Write(ieUnt,*)  ieUnt,ibYr,ibJd,ibHr,ieYr,ieJd,ieHr,nObs, -
     1 'Malformed surface data line 1, date info in error!'
        anErr = .TRUE.
      End If

c --- calculating the correct number of hours (nObs) for dynamic allocation
      nObs = 0
      If (ibYr.EQ.ibYr) Then 
        nObs = (ieJd-ibJd)*24 + (ieHr-ibHr) +1
      Else    
        nObs = (364-ibJd) * 24
        If (CheckLeap(ibYr).EQ..TRUE.) Then 
          nObs = nObs+24
        End If
        Do i=ibYr+1, ibYr-1
          nObs = nObs + (365*24) 
          If (CheckLeap(i).EQ..TRUE.) Then 
            nObs = nObs + 24
          End If
        End Do
        nObs = ieJd*24 + ieHr
      End If      
      CalcNumObs = anErr
      Return
      End

!=======================================================================
      Logical Function CheckEnds(ieUnt,sLen,nObs,sYr,sJd,sHr,yr,jd,hr,
     1                           iYr,iJd,iHr,bIdx,eIdx)
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Integer ieUnt,sYr,sJd,sHr,yr,jd,hr
      Integer iYr(nObs),iJd(nObs),iHr(nObs)
      Integer sLen,nObs,bIdx,eIdx
      
      Integer i
      Logical anErr

c --- Find start time index surf.dat file
      bIdx = 0
      Do i=1, nObs
        If (sYr.EQ.iYr(i)) Then
          If (sJd.EQ.iJd(i)) Then
            If (sHr.EQ.iHr(i)) Then
              bIdx = i 
            End If
          End If    
        End If
      End Do

c --- Find End time index surf.dat file
      eIdx = 0
      Do i=bIdx, nObs
        If (yr.EQ.iYr(i)) Then
          If (jd.EQ.iJd(i)) Then
            If (hr.EQ.iHr(i)) Then
              eIdx = i 
            End If
          End If    
        End If
      End Do
cLst
      Write(ieUnt,*) 'The calculated number of observations ', nObs
      Write(ieUnt,*) 'B&E observation indices', bIdx, eIdx
      Write(*,*) 'The calculated number of observations ', nObs
      Write(*,*) 'B&E observation indices', bIdx, eIdx
cLst

c --- Time seqence checks
      anErr = .FALSE.
      If (iYr(1).NE.ibYr .OR. iJd(1).NE.ibJd .OR. iHr(1).NE.ibHr) Then
        Write(ieUnt,*) 
     1  'Data file start time and first obeservation time do not match!'
        anErr = .TRUE.
      End If

      If (sLen.GT.nObs+2) Then
        Write(ieUnt,*) 
     1  'Data file can not support simualtion length!'
        anErr = .TRUE.
      End If

      If (bIdx.LT.2) Then
        Write(ieUnt,*) 
     1  'Data file can not support simualtion start time!'
        anErr = .TRUE.
      End If

      If (eIdx.EQ.0 .OR. eIdx.EQ.nObs) Then
        Write(ieUnt,*) 
     1  'Data file can not support simualtion end time!'
        anErr = .TRUE.
      End If
      CheckEnds = anErr
      End

!=======================================================================
      Real Function CalcWindDir(u, v, ws) 
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Real u, v, ws
    
      Real wd
      Real rad2Deg
        
      rad2Deg = 57.29577951
      If (-1.0 * U .GE. 0.0) Then
        If (.Not. (ACOS(-V/ws).EQ.-99999999.0)) Then
          wd = ACOS(-V/ws) * rad2Deg
        Else
          If (V.LT.0) Then
            wd = 0.0
          Else
            wd = 180.0
          End If
        End If
      Else
        If (.Not.(ACOS(-V/ws).EQ.-99999999.0)) Then
          wd = 360 - ACOS(-V/ws) * rad2Deg
        Else
          If (V.LT.0) Then
            wd = 0.0
          Else
            wd = 180.0
          End If
        End If
      End If
      CalcWindDir = wd
      End

!=======================================================================
      Subroutine ifillvalues(nSta, nObs, bIdx, eIdx, val, default) 
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Integer nSta, nObs, bIdx, eIdx, default
      Integer val(nObs, nSta) 
        
      Integer i, j, k, n, cnt, fillCnt
      Real tot, m

c --- Fill missing end values - part 'a' in surf check Write up
c     Write(*,*) 'Input for fill', nSta, nObs, bIdx, eIdx, default
      Do j=1, nSta
        fillCnt=0
c ---   front End values
        Do i=bIdx-1, eIdx+1
          If (val(i,j).NE. 9999) Then
            goto 1000
          End If
        End Do
1000    If (i.LT.eIdx+1) Then
          Do k=bIdx-1, i-1
            val(k,j) = val(i,j) 
c       Write(*,*) 'front End fill', val(i,j), k, j
        fillCnt = fillCnt+1
          End Do
        Else
c ---     Fill missing values between Ends - part 'c' in surf check Write up 
          Do i=bIdx-1, eIdx+1
            cnt = 0
            tot = 0.0
            Do k=1, nSta
              If (val(i,k) .NE.9999) Then
                tot = tot + val(i,k) 
                cnt = cnt+1
              End If
            End Do
            If (cnt.NE.0) Then
              val(i,j) = tot/cnt
c       Write(*,*) 'average fill', val(i,j), i, j, tot, cnt
              fillCnt = fillCnt+1
            Else
c ---         Fill missing values with default - part 'd' in surf check Write up 
              val(i,j) = default
c       Write(*,*) 'default fill', val(i,j), i, j
              fillCnt = fillCnt+1
            End If
          End Do
        End If

c ---   back End values
        Do i=eIdx+1, bIdx-1, -1
          If (val(i,j).NE. 9999) Then
            goto 2000
          End If
        End Do
2000    If (i.GT.bIdx-1) Then
          Do k=i+1, eIdx-1
            val(k,j) = val(i,j) 
c       Write(*,*) 'back End fill', val(k,j), k, j
            fillCnt = fillCnt+1
          End Do
        End If
c ---   Fill missing End values between Ends - part 'b' in surf check Write up 
        Do i=bIdx-1, eIdx+1
          If (val(i,j).EQ.9999) Then
            k = i+1
            Do while (val(k,j).EQ.9999) 
              k=k+1
            End Do
c ---       calculate slope
            m = (val(k,j) -val(i-1,j)) / (k-(i-1)) 
c ---       fill in values
            Do n=i, k-1
              val(i,j) =val(i-1,j) + m*(n-(i-1)) 
c       Write(*,*) 'between fill', val(i,j), i, j, m
              fillCnt = fillCnt+1
            End Do
          End If
        End Do
        Write(*,*) 'Station Done->', j, ' Filled values->', fillCnt
      End Do
      End

!=======================================================================
      Subroutine rfillvalues(nSta, nObs, bIdx, eIdx, val, default) 
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Integer nSta, nObs, bIdx, eIdx
      Real val(nObs, nSta), default
        
      Integer i, j, k, n, cnt, fillCnt
      Real tot, m

c --- Fill missing End values - part 'a' in surf check Write up
c     Write(*,*) 'Inputs for rfill', nSta, nObs, bIdx, eIdx, default
      Do j=1, nSta
        fillCnt=0
c ---   fill front End values
        Do i=bIdx-1, eIdx+1
          If (val(i,j).NE. 9999.0) Then
            goto 1000
          End If
        End Do
1000    If (i.LT.eIdx+1) Then
          Do k=bIdx-1, i-1
            val(k,j) = val(i,j) 
c       Write(*,*) 'front End fill', val(i,j), k, j
            fillCnt = fillCnt+1
          End Do
        Else
c ---     Fill missing values between Ends - part 'c' in surf check Write up 
          Do i=bIdx-1, eIdx+1
            cnt = 0
            tot = 0.0
            Do k=1, nSta
              If (val(i,k) .NE.9999.0) Then
                tot = tot + val(i,k) 
                cnt = cnt+1
              End If
            End Do
            If (cnt.NE.0) Then
              val(i,j) = tot/cnt
c       Write(*,*) 'average fill', val(i,j), i, j, tot, cnt
              fillCnt = fillCnt+1
            Else
c ---         Fill missing values with default - part 'd' in surf check Write up 
              val(i,j) = default
c       Write(*,*) 'default fill', val(i,j), i, j
              fillCnt = fillCnt+1
            End If
          End Do
        End If

c ---   back End values
        Do i=eIdx+1, bIdx-1, -1
          If (val(i,j).NE. 9999.0) Then
            goto 2000
          End If
        End Do
2000    If (i.GT.bIdx-1) Then
          Do k=i+1, eIdx-1
            val(k, j) = val(i,j) 
c       Write(*,*) 'back End fill', val(k,j), k, j
            fillCnt = fillCnt+1
          End Do
        End If
c ---   Fill missing End values between Ends - part 'b' in surf check Write up 
        Do i=bIdx-1, eIdx+1
          If (val(i,j).EQ.9999.0) Then
            k = i+1
            Do while (val(k,j).EQ.9999) 
              k=k+1
            End Do
c ---       calculate slope
            m = (val(k,j) -val(i-1,j)) / (k-(i-1)) 
c ---       fill in values
            Do n=i, k-1
              val(i,j) =val(i-1, j) + m*(n-(i-1)) 
c       Write(*,*) 'between fill', val(i,j), i, j, m
              fillCnt = fillCnt+1
            End Do
          End If
        End Do
        Write(*,*) 'Station Done->', j, ' Filled values->', fillCnt
      End Do
      End

!=======================================================================
      Logical Function CheckLeap(year) 
c
c --- PURPOSE:
c
c --- INPUTS:
c
c --- OUTPUT:
c
!=======================================================================
      Integer year

      If ((mod(year, 4).EQ.0) .AND. ((mod(year, 100).NE.0) .OR.
     1    (mod(year, 400).EQ.0)) ) Then
        CheckLeap=.TRUE.
      Else
        CheckLeap=.FALSE.
      End If
      End  

!=======================================================================
      subroutine julday(io, iYr, iMo, iDy, iJday) 
!=======================================================================
c
c --- CALUTILS   Version: 2.1      Level: 000602                 JULDAY
c ---            J. Scire, SRC
c
c --- PURPOSE:  Compute the Julian day number from the Gregorian
c               date (month, day) 
c
c --- UPDATE
c ---               000602  (DGS) : YYYY format for year
c
c --- INPUTS:
c            IO - Integer      - Unit number for list file output
c           iYr - Integer      - Year
c           IMo - Integer      - Month
c           iDy - Integer      - Day
c
c --- OUTPUT:
c          iJay - Integer      - Julian day
c
c --- JULDAY called by:  host subroutines
c --- JULDAY calls:      none
!=======================================================================
c
      Integer kday(12) 
      data kday/0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334/
c
c --- Check for valid input data
      ierr=0
c --- Check for valid month
      If(imo.lt.1.OR.imo.gt.12) ierr=1
c --- Check for valid day in 30-day months
      If(imo.eq.4.OR.imo.eq.6.OR.imo.eq.9.OR.imo.eq.11) Then
         If(iDy.gt.30) ierr=1
      Else If(imo.eq.2) Then
         If(mod(iYr, 4).EQ.0) Then
c ---       February in a leap year
            If(iDy.gt.29) ierr=1
         Else
c ---       February in a non-leap year
            If(iDy.gt.28) ierr=1
         Endif
      Else
c ---    Check for valid day in 31-day months
         If(iDy.gt.31) ierr=1
      Endif
c
      If(ierr.eq.1) Then
         Write(io,*) 
         Write(io,*) 'ERROR in SUBR. JULDAY'
         Write(io,*) 'Invalid date - iYr = ', iYr, ' IMO = ', 
     1    imo, ' iDy = ', iDy
         Write(*,*) 
         Stop 'Halted in JULDAY -- see list file.'
      Endif
c
c --- Compute the Julian day
      iJday=kday(imo) +iDy
      If(imo.le.2) return
      If(mod(iYr, 4).EQ.0) iJday=iJday+1
c
      Return
      End

!=======================================================================
      subroutine lineregress(m,b,sigma,xtab,ytab,ntab)
!=======================================================================
c --- AUTHOR:  JRishel
c --- PURPOSE: Calculate the slope (m) and intercept (b) of a best fit
c			 line to a group of points (xtab,ytab)
c
c			 Formulations adapted from "Numerical Recipes, The Art of
c              Scientific Computing (Fortran Version)", 1990.
c
c --- INPUTS:
c			   xtab - real array  - x point values
c			   ytab - real array  - y point values
c               sigma - real array  - uncertainity in y points
c			   ntab - integer	  - number of points
c
c --- OUTPUT:
c				  m - real        - slope of line
c                   b - real        - intercept
!=======================================================================
c
      real sigma(ntab),xtab(ntab),ytab(ntab)
	real m,b
	integer ntab
c
c	perform summations for regression equation
      do 20 i= 1,ntab
		s = s + (1/sigma(i)**2)
		sx = sx + (xtab(i)/sigma(i)**2)
		sy = sy + (ytab(i)/sigma(i)**2)
		sxx = sxx + ((xtab(i))**2/sigma(i)**2)
		sxy = sxy + ((xtab(i)*ytab(i))/sigma(i)**2)
 20	continue

c	calculate coefficients for straight line
	delta=s*sxx-(sx)**2
c	slope
	m=(s*sxy-sx*sy)/delta
c	intercept
	b=(sxx*sy-sx*sxy)/delta

      return
      end

!=======================================================================
      subroutine linint(x,y,xtab,ytab,ntab)
!=======================================================================
c --- AUTHOR:  JRishel
c --- PURPOSE: Given a value of x return a value of y based on interpolation
c              within a table of y values (ytab) corresponding to a table of x
c              values (xtab).  The subroutine assumes that the values in xtab
c              increase monotonically.  Efficiency is increased by remembering
c              the table points used in the last call (ilast) xtab and ytab
c              are provided through the argument list as is their length ntab.
c
c --- INPUTS:
c                   x - real       - known value of x 
c			   xtab - real array - x point values
c			   ytab - real array - y point values
c			   ntab - integer	 - number of points
c
c --- OUTPUT:
c				  y - real       - interpolated value of y paired with known value of x
!=======================================================================
      real xtab(ntab),ytab(ntab)
c
      save ilast
c
      data ilast/1/
c
c    Start the search from the last point of table use index
c
      if (x.le.xtab(ilast+1)) then
c
c    Search down the table from point of last use
c
          do 20 i1=ilast,1,-1
              if(x.ge.xtab(i1)) go to 60
  20          continue
          write(6,*) 'x = ', x, '  is below the table range'  
          stop
      else
c
c    Search up the table from point of last use
c
          do 40 i1=ilast+1,ntab-1
              if(x.le.xtab(i1+1)) go to 60
  40          continue
          write(6,*) 'x = ', x, '  is above the table range'
          stop
      endif
c
c   Bounding points found, interpolate
c
  60  wx=(x-xtab(i1))/(xtab(i1+1)-xtab(i1))
      y=(1-wx)*ytab(i1)+wx*ytab(i1+1)
      ilast=i1
      return
      end
!=======================================================================